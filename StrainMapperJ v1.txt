// -------------------------------------------------------------
// -------------------------------------------------------------
//
//	Strain Mapping using Elastic Registration
//		Between Two Images (pre- and post-laser ablation, pre- and post- movement, etc).
//
//	1. Elastic registration of the two files.
//	2. Convert transform to raw x- and y-displacement. These are actually velocities.
//	3. Calculate absolute displacement image. (velocity map)
//	4. Calculate strain maps (eps_x, eps_y, and eps_xy). (strain rates)
//	5. Calculate principle strain (rate) maps (eps1, eps2, theta),
//	6. Produce grid maps of principle strain (rate) circles and displacement (velocity) vectors.
// 	7. Calculate vorticity from x- and y-displacements.
//
//	Previous versions used to track bead displacements and map strain during gastrulation, ablation etc. See:
//		Arnold et al (2019) Elife 8: e39065. doi: 10.7554/eLife.39065
//		Feroze et al (2015) Dev Biol 398(1): 57-67. doi: 10.1016/j.ydbio.2014.11.011
//		Jackson et al (2017) Curr Biol 27(9): 1326-1335. doi: 10.1016/j.cub.2017.03.065
//		Kim et al (2014) Proc Natl Acad Sci U S A 111(40): 14366-71. doi: 10.1073/pnas.1405209111
//		Song et al (2015) Biomaterials 58: 1-9. doi: 10.1016/j.biomaterials.2015.04.021
//		Stepien et al (2019) PLoS One 14(6): 460774. doi: 10.1371/journal.pone.0218021
//		Yang et al (2025) Small Methods 9(8): e2500136. doi: 10.1002/smtd.202500136
//		Zhou et al (2010) Development 137: 2785-94. doi: 10.1242/dev.045997
//		Zhou et al (2015) Development 142: 692-701. doi: 10.1242/dev.116533
//	Oct 7, 2018 -
//		+) use 'pre' and 'post' images to map strain.
//		+) optional - add mask to the second slice of pre-image to indicate region over the cut (black, 0)
//		+) integrate strain map calculation following displacement mapping.
//	Dec 31, 2018 -
//		+) clarified shear strain and theta calculation (corrected 03)
//	Jan 2, 2019 -
//		+) added strain ellipse maps (new 05) -- draws strain circles in a grid
//	Jan 3, 2019 -
//		+) added vector maps (new 04) -- draws displacements with arrows in a grid
//	Mar 5, 2020
//		+) fixed strain ellipse map, correctly draws the principle strain ellipses in a grid
//			produces both an ellipse-only image as well as a composite ellipse-and-image.
//		+) combined all 5 macros into a single macro (StrainMapper) with multiple functions; 
//			works only on a single image pair.
//		+) Added automation to process timelapse sequences/stacks. 
//			Best to reduce to the number of images to ensure sufficient signal-to-noise in strain map.
//	Mar 6, 2022
//		+) made vectors larger
// 	May 23, 2023
//		+) removed Mac.os replace for directory names.
//		+) increased density of the grid for vector and ellipses. Changed dsquare from a 40 by 40 region to a 20 by 20 region.
//		(fixed 10/22/23) PROBLEM -- currently image pair should be 8-bit for the overlay to work correctly.
// 	Oct 25, 2023  --- Version 1.0
//		+) added dialog box
//		+) added vorticity output
//    		+) added choice of arrow for vectors
//		+) user scales size of grid to plot ellipses and vectors
//		+) Removes edge effects, sets min/max and used special LUTS for each image:
//			"phase" for real images with negative and positive values, like eps, mpl for positive only images such as Abs-displacement.
//		+) Fixed vector directions
//		+) Split post-processing macros to adjust LUTs etc to another set of macros (PostMapper)
//	Nov 4, 2023, Version 1.21
//		+) Added the "Trajectory" output. This output generates an image consisting of a random set of dots and then deforms them
//			according to the stack of solutions from bUnwarpJ. Uses the deformation transform for each transition. The resulting image
//			looks like a mock-image of a confocal image sequence tracking nuclei with H2B. 
//			Suggestion - try overlaying the maximum-intensity-projection image of the trajectory on top of the 
//				average-intensity-projection Vorticity image.
//	Dec 4, 2023, v 1.22
//		+) troubleshooting a problem with poor fitting of the solution by bUnwarpJ. 16-bit stacks sometimes cause unwarping to fail and
//			generated spurious high results. Displacements ranged in orders of 1000's of pixels. When the image format was changed to 8-bit, the warp
//			procedure was reasonable, producing displacements in the range of 5 to 20 pixels between stretch steps. Changing the "image weight" from 10 to 2
//			fixed the problem. Changing weights to 4 worked but 5 did not. Set the weight to 2.
//  	Aug 25, 2024, v 3: Geneva Masak
//      	+) Made changes to the bUnwarpJ call. Changed the "image_subsample_factor" from 0 to 1; "image weight" from 2 to 1.0; "divergence_weight" from 0 to 1; 
//        	"consistency_weight" from 10 to 20; "stop_threshold" from 0.005 to 0.01. Images seem to be registering more 'accurately' and with more consistency
//		+) Added a batch processing option to process all .tif files in a folder instead of a single stack or image pair.
//  	Sept 6, 2024, v 5: Geneva Masak
//		+) Added SIFT correspondences before bUnwarpJ call, which should add points to each image and turn them into landmarks based on a SIFT Affine 
//		registration. Not sure if landmark_weight value needs to be changed. bUnwarpJ seems to recognize points with value at 0.
//	Sep 27, 2024, v 1.23: Jing Yang
//		+) added the "CumStrain" output. This output adds step strain to get cumulative strain at every step for Exx and Eyy. Since engineering strain is not 
//			directly "addable", this macro converts engineering strain to true strain. True strain is "addable", then finally converts it back to engineering
//			strain. It outputs "Cum_Epsilon_xx" and "Cum_Epsilon_yy" images.
//		+) added "CumArea" output. Takes step area strains and converts them to a "true" area strain.
//  	Oct 15, 2024, v 5.1: Geneva Masak
//		+) Changed landmark_weight value from 0 to 1; Changed SIFT values to landmark_size = 10
//	Oct 17, 2024, v 5.2: Geneva Masak
//		+) Added option to create a mask. New set of options in dialogue box to create a mask to register image only to regions within ROI ("Mask Outside")
//		or to regions only outside ROI ("Mask Inside"). Typically will want to register only inside an ROI.
//		Macro will check if MASK.tif file exists in directory first.
//              See Rivera-Alba and Ignacio Arganda-Carreras for details of integrating both SIFTS and bUnwarpJ at https://imagejdocu.list.lu/macro/affine_consistent_elastic_registration
//      Dec 30, 2025, integrated Masak and Yang modifications into current version. 
//              +) Split the macro into two parts, the first taking care of processing and the second focused on post-processing.
//              +) New version will be published as StrainMapperJ version 1.0 and posted to GitHub.
//
//	Future -- Normalize step strain circles and step vector magnitudes across the full stack.
//             -- Use actual units, e.g. strain/hour for eps, um/hour for displacement (actually velocity), or 1/hour for vorticity.
//                Currently, image dimensions are scaled in "pixels" and the values of the pixel intensity are dictated by pixel and "interval" units.
//                For publications the output files need to be rescaled to the appropriate units of um, um/hour, etc.
//             -- Add cumulative displacements
//             -- Add contour outputs
//             -- Update vortex analysis to Masak et al. Port swirl functions from Python to ImageJ
//             -- Enable tracking of strain in packets, e.g., ROI domains that are displaced and shaped by morphogenesis. This would provide information on
//                the mechanical conditions experienced by a patch of translating cells during morphogenesis.
//
//	Lance Davidson, lad43@pitt.edu (bug reports welcome)
// -------------------------------------------------------------
// -------------------------------------------------------------

var howfine;
var sample, target, source;
var dotfile;
var wid, hei;
var grain;
var useland = true;
var landwt = 10;
var imagewt = 10;
var consistwt = 10;
var converge = 0.005;

setOption("QueueMacros",true);

macro "StrainMapperJ [1]"
{
	file=f1=f2=dir="";

	dspan = 80;
	grain = "fine";

	runtypes = newArray("Image Stack", "Image Pair");
	arrowtypes = newArray("Medium Closed", "Large Closed", "Small Closed", "Large Open", "Medium Open", "Small Open", "Large Notched", "Medium Notched", "Small Notched");
	modetypes = newArray("Accurate", "Fast");
	masktypes = newArray("Mask Outside", "Mask Inside", "None");

	Dialog.create ("StrainMapperJ");
	Dialog.addChoice ("Run Type", runtypes);
	Dialog.addNumber ("Grid Size for Vector/Ellipse ROI (in pixels):", dspan);
	Dialog.addChoice ("Arrow Type:", arrowtypes);
	Dialog.addChoice ("Mode Type", modetypes);
	Dialog.addCheckbox ("Use SIFTS/Landmarks", useland)
	Dialog.addNumber ("Landmark weight", landwt);
	Dialog.addNumber ("Image weight", imagewt);
	Dialog.addNumber ("Consistency weight", consistwt);
	Dialog.addNumber ("Convergence Criteria", converge);
	Dialog.addChoice ("Use mask?", masktypes);
	Dialog.show ();

	expt = Dialog.getString();
	runtype = Dialog.getChoice();
	dspan = Dialog.getNumber();
	arrowtype = Dialog.getChoice();
	mode = Dialog.getChoice();
	useland = Dialog.getCheckbox();
	landwt = Dialog.getNumber();
	imagewt = Dialog.getNumber();
	consistwt = Dialog.getNumber();
	converge = Dialog.getNumber();
	masktype = Dialog.getChoice();

	// Span of the ROI for vector and ellipse display elements.
	dlen = dspan;
    	
	if (runtype == "Image Pair") 
	{ 
	
//
//
//	Before running: create folder containing two images. Make sure the interval between images is sufficient to provide meaningful info.
//	From experience, this interval includes approx 2 to 5% strain. Too small a difference between images will 
//	result in very noisy strain maps. Don't trust me - try it yourself!
//
//
			
		open("");
		run("16-bit");
		f1 = getTitle(); 		
		if(bitDepth()!=8 && bitDepth()!=16)
		{
			exit("This macro requires 8- or 16-bit images!");
		}
		close();


		open("");
		run("16-bit");
		f2 = getTitle(); 
		if(bitDepth()!=8 && bitDepth()!=16)
		{
			exit("This macro requires 8- or 16-bit images!");
		}
		close();

		dir = File.directory;

		//	if (getInfo("os.name") != "Windows") dir = replace(dir,"/","\\");

		showStatus("Starting Strain Mapper on Two Images");
		
		print("Filename f1: "+f1+" filename f2: "+f2+" directory "+dir);
		
		setBatchMode('hide');

		masterMapper(dlen, arrowtype, f1, f2, dir, dir, masktype);

		if (isOpen("Results")) 
		{
			selectWindow("Results");
			run("Close");
		}

		if (isOpen("Log")) 
		{
			selectWindow("Log");
			run("Close");
		}

		setBatchMode('show');
		showStatus("Done SMJ Image Pair");
	}
	else if (runtype == "Image Stack")
	{
	//
	//	Before running: create a substack where the interval between images is sufficient to provide meaningful info.
	//	From experience, this interval includes approx 2 to 5% strain. Too small a difference between images will 
	//	result in very noisy strain maps. Don't trust me on this - try it yourself!
	//
	//
		open("");
		run("16-bit");
		s1 = getTitle();


	//	if (getInfo("os.name") != "Windows") dir = replace(dir,"/","\\");

		if (nSlices == 1)
		{
			exit("This macro needs a stack!");
		}

		if (bitDepth()!=8 && bitDepth()!=16)
		{
			//exit("This macro needs an 8- or 16-bit stack!");
			run("16-bit");
		}

		dir = File.directory;

		showStatus("Starting StrainMapper on Stack");

		setBatchMode('hide');

		setup(s1, dir);

		if (masktype == "None")
		{
			//do nothing
		}
		else 
		{
			SetMask(s1,dir,masktype);
		}

		selectWindow(s1);
		nS = nSlices;
		close();

		stackMapper(dlen, arrowtype, nS, dir, masktype);

		if (isOpen("Results")) 
		{
			selectWindow("Results");
			run("Close");
		}

		if (isOpen("Log")) 
		{
			selectWindow("Log");
			run("Close");
		}

		setBatchMode('show');
		showStatus("Done SMJ Stack");
	}
}


macro "Add Calibration Bar" {

//
// Alternative to using Menu approach 'Analyze->Tools->Calibration Bar'
//

	run("Calibration Bar...", "location=[Lower Right] fill=White label=Black number=5 decimal=2 font=12 zoom=2 bold overlay");

}


//////////////////////////////////////////////////////////////////////////////////////////////
//
//
//	Mapper Specific FUNCTIONS
//
//
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function setup(s1, dir)
{

//
//

	sep = "/";
	if (getInfo("os.name") != "Windows") sep = "\\";
	
	selectWindow(s1);
	mystack = getTitle();
	stackwid = getWidth();
	stackhei = getHeight();

	nStack = nSlices;

	for (i=1; i<nStack; i++)
	{
		path = dir + pad3(i)+sep;
		
		print("setup: path is: "+path);
			
		File.makeDirectory(path);
		
		selectWindow(mystack);
		setSlice(i);	
		run("Select All");
		run("Copy");
		newImage(pad3(i), "16-bit", stackwid, stackhei, 1);
		newName = getTitle();
		run("Paste");
		saveAs("tif",path+newName); close();
		
		print("setup loop - first file: "+path+newName);
		
		
		selectWindow(mystack);
		setSlice(i + 1);
		run("Select All");
		run("Copy");
		newImage(pad3(i + 1), "16-bit", stackwid, stackhei, 1);
		newName = getTitle();
		run("Paste");
		saveAs("tif",path+newName); close();
		
		print("setup loop - second file: "+path+newName);
	}
	
}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function stackMapper(dlen, arrowtype, nS, dir, masktype)
{

//
// follows same structure as setup
//

	sep = "/";
	if (getInfo("os.name") != "Windows") sep = "\\";
	
//	print ("in stack mapper");

	for (i=1; i<nS; i++)
	{
		path = dir + pad3(i)+sep;
		
		first = pad3(i);

		f1 = first+".tif"; 
		
		second = pad3(i+1);
		
		f2 = second+".tif"; 
		
		print("stackMapper loop - first file: "+f1);
		print("stackMapper loop - second file: "+f2);
				
//		print(f1);
//		print(f2);
//		print(path);
		
		masterMapper(dlen, arrowtype, f1, f2, path, dir, masktype);

	}
}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 


function masterMapper(dlen, arrowtype, f1, f2, dir, dir1, masktype)
{
//
//	1) unwarp -- runs BunwarpJ - this creates the transformation matrices
//
//	2) trans2raw -- converts transforms to raw positions
//
//	3) raw2abs -- converts raw positions to absolute displacements (velocity)
//
//	4) abs2eps -- converts displacement to x & y strains 
//
// 	5) abs2vort -- convert displacements (velocity) to vorticity map
//
//	6) abs2vector -- convert displacement maps to a grid of displacement arrows
//
//	7) eps2eps12 -- converts x & y strains to principal strains
//
//	8) eps2ellipse -- convert principal strain maps to a grid of strain ellipses
//

//
//	scale displacements to um/hour instead of pixel/interval
//

	print("masterMapper - first file: "+f1);
	print("masterMapper - second file: "+f2);
	print("masterMapper - dir: "+dir);
	
	unwarp(mode, f1, f2, dir, dir1, masktype);
	trans2raw(f1, f2, dir);
	raw2abs(dir);
	run("Collect Garbage");
	
	abs2eps(dir);
	abs2vort(dir);
	abs2vector(dspan, arrowtype, dir, f1);
	run("Collect Garbage");
	
	eps2eps12(dir);
	eps2ellipse(dspan, dir, f1);
	run("Collect Garbage");
	
	AbsCurvRotation(dir);
	run("Collect Garbage");

}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function unwarp(mode, f1, f2, dir, dir1, masktype)
{

//
//	runs elastic registration - BunwarpJ - to calculate transform from one image to deformed image
//	Transforms include the coefficients of the beta-splines for the elastic registration.
//
	print("unwarp - first file: "+f1);
	print("unwarp - second file: "+f2);
	print("unwarp - dir: "+dir);
	
	path = dir;
	
	file1 = dir+f1;
	file2 = dir+f2;
	
	open(file1);
	run("16-bit");
	ff1 = getTitle();
	
	open(file2);
	run("16-bit");
	ff2 = getTitle();
	
	directTransSave = dir+"direct_transf.txt";
	inverseTransSave = dir+"inverse_transf.txt";
	
	rawSave = dir+"raw.txt";
	
	home2 = getDirectory("startup");
	
	if (masktype == "None")
	{
		//do nothing
	}
	else {
		maskdir = dir1+"MASK.tif";
		open(maskdir);
		mask = getTitle();
		run("Select All");
		run("Copy");
		selectImage(ff1);
		run("Add Slice");
		run("Select All");
		run("Paste");
		setSlice(1);
		selectImage(ff2);
		run("Add Slice");
		run("Select All");
		run("Paste");
		setSlice(1);
		
	}
	//previous - general sifts use - not working
	if (useland)
	{
	run("Extract SIFT Correspondences", "source_image="+ff1+" target_image="+ff2+" initial_gaussian_blur=1.60 steps_per_scale_octave=3 minimum_image_size=64 maximum_image_size=4024 feature_descriptor_size=4 feature_descriptor_orientation_bins=8 closest/next_closest_ratio=0.92 filter maximal_alignment_error=150 minimal_inlier_ratio=0.05 minimal_number_of_inliers=7 expected_transformation=Affine");
	}

	//previous - general use
	// run("bUnwarpJ", "source_image=["+ff1+"] target_image=["+ff2+"] registration="+mode+" image_subsample_factor=0 initial_deformation=[Very Coarse] final_deformation=[Fine] divergence_weight=1.0 curl_weight=0 landmark_weight=1 image_weight=1 consistency_weight=20 stop_threshold=0.01 save_transformations save_direct_transformation=["+directTransSave+"] save_inverse_transformation=["+inverseTransSave+"]");

	//251227 obstacle no sifts -- not working 	
	// run("bUnwarpJ", "source_image=["+ff1+"] target_image=["+ff2+"] registration="+mode+" image_subsample_factor=0 initial_deformation=[Very Coarse] final_deformation=[Fine] divergence_weight=1.0 curl_weight=0 landmark_weight=0 image_weight=1 consistency_weight=20 stop_threshold=0.01 save_transformations save_direct_transformation=["+directTransSave+"] save_inverse_transformation=["+inverseTransSave+"]");

// works better for low res
run("bUnwarpJ", "source_image="+ff1+" target_image="+ff2+" registration="+mode+" image_subsample_factor=0 initial_deformation=[Very Coarse] final_deformation=[Fine] divergence_weight=1 curl_weight=0 landmark_weight="+landwt+" image_weight="+imagewt+" consistency_weight="+consistwt+" stop_threshold="+converge+" save_transformations save_direct_transformation=["+directTransSave+"] save_inverse_transformation=["+inverseTransSave+"]");

	//
	//	Wait until bUnwarpJ is done.
	//

	while (!isOpen("Registered Source Image"))
	{
	// do nothing
	}
	
	while (!isOpen("Registered Target Image"))
	{
	// do nothing
	}
	
	selectWindow("Registered Source Image");
	save(path+"Registered Source Image"+".tif");
	close();
	
	selectWindow("Registered Target Image");
	save(path+"Registered Target Image"+".tif");
	close();
	
	selectWindow(ff1); close();
	
	selectWindow(ff2); close();
		
	if (masktype != "None") {selectWindow(mask); close();}
 
}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function trans2raw(file1, file2, dir)
{
//
//
//	convert transforms produced by bUnwarpJ into raw displacement files
//	Raw displacement files (unique to bUnwarpJ) contain pixel-by-pixel changes in position
//	that are needed to move intensity patterns from the first image into the second image.
//
//

	path = dir;

	file1 = dir+f1;
	file2 = dir+f2;
	
	directTransSave = dir+"direct_transf.txt";
	inverseTransSave = dir+"inverse_transf.txt";
	
	rawSave = dir+"raw.txt";
	
	call("bunwarpj.bUnwarpJ_.convertToRawTransformationMacro", file1, file2, directTransSave, rawSave);
	
}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function raw2abs(dir)
{
//
//
//	convert raw position files into deltax and deltay displacement maps (velocity maps).
//	The deltax and deltay contain 32-bit real valued images that contain the absolute displacements,
//	in pixels, that are needed to move intensity patterns from the first image into the second image.
//
//	This function interfaces products of bUnwarpJ with the rest of the image processing.
//	The deltax and deltay products of this function are stored locally with the orginal image pair.
//
//	Note: 32-bit real images are merely large matrices.
//
//

	path = dir;

//	file1 = dir+f1;
//	file2 = dir+f2;
	
	directTransSave = dir+"direct_transf.txt";
	inverseTransSave = dir+"inverse_transf.txt";
	
	rawSave = dir+"raw.txt";
	
	bigstring = File.openAsString(rawSave);
	
	
	lines = split(bigstring, "\n");

	widstr = split(lines[0], "=");
	heistr =  split(lines[1], "=");

	width = parseInt(widstr[1]);
	height = parseInt(heistr[1]);

	// real data starts at lines[4].

	newImage("deltaX", "32-bit", width, height, 1);
	selectWindow("deltaX");

	for (i=4; i<4+height; i++) 
	{

		pixels = split(lines[i],"");
		for (j=1; j<width; j++)
		{
			x = j-1;
			y = i-4;
			setPixel(x, y, x - parseFloat(pixels[j-1]));
		}

	}

	// *** start the Y data.

	newImage("deltaY", "32-bit", width, height, 1);
	selectWindow("deltaY");

	for (i=6+height; i<6+(2*height); i++) 
	{

		pixels = split(lines[i],"");
		for (j=1; j<width; j++)
		{
			x = j-1;
			y = i-(6+height);
			setPixel(x, y, y - parseFloat(pixels[j-1]));
		}
	}

	
// 
//	calculate the magnitude or absolute displacement from vectorial x and y displacements.
//
	
	imageCalculator("Multiply create 32-bit", "deltaX","deltaX");
	imageCalculator("Multiply create 32-bit", "deltaY","deltaY");
	imageCalculator("Add create 32-bit", "Result of deltaX","Result of deltaY");
	run("Square Root");
	
	run("Select All");
	run("Enlarge...", "enlarge=-2");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");
		
	run("Enhance Contrast", "saturated=0.25");
	
	rename("AbsDisp"); run("mpl-plasma"); save(path+"absdisp.tif"); close();

	//
	// close all other windows
	//

	selectWindow("deltaX"); 	
	run("Select All");
	run("Enlarge...", "enlarge=-2");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");
	run("phase"); fixminmax(); save(path+"deltaX.tif"); close();
	
	selectWindow("deltaY"); 	
	run("Select All");
	run("Enlarge...", "enlarge=-2");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");
	run("phase"); fixminmax(); save(path+"deltaY.tif"); close();
	
	selectWindow("Result of deltaX"); close();
	selectWindow("Result of deltaY"); close();
	

}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function abs2eps(dir)
{
//
//
//	converts the displacement maps into strain maps in the x- and y- directions.
//	Strains are calculated across a 3x3 matrix from the displacement image arrays.
//
//	products of this function, epsx, epsy, epsxy, and epsyx are stored locally with the original image pair.
//
//

	
	open(dir+"deltaX.tif");
	rename("deltaX");
	deltax = getTitle();
		
	open(dir+"deltaY.tif");
	rename("deltaY");
	deltay = getTitle();

	selectWindow(deltax);

	wid = getWidth();
	hei = getHeight();
	sli = nSlices;
	
	newImage("epsx", "32-bit", wid, hei, 1);
	epsx = getTitle();
	

	newImage("epsy", "32-bit", wid, hei, 1);
	epsy = getTitle();
	

	newImage("epsyx", "32-bit", wid, hei, 1);
	epsyx = getTitle();
		
	newImage("epsxy", "32-bit", wid, hei, 1);
	epsxy = getTitle();
	
	for (j=2; j<=(wid-1); j++)
	{
	for (k=2; k<=(hei-1); k++) 	
	{
		jp = j+1;
		jm = j-1;

		kp = k+1;
		km = k-1;
		selectWindow(deltax);

		xm = getPixel(jm,k);		
		xp = getPixel(jp,k);

		ex = (xp - xm)/2;

		selectWindow(epsx);
		setPixel(j,k,ex);

		xym = getPixel(j,km);
		xyp = getPixel(j,kp);

		exy = (xyp - xym)/2;
		selectWindow(epsxy);
		setPixel(j,k,exy);

		selectWindow(deltay);

		ym = getPixel(j,km);
		yp = getPixel(j,kp);

		ey = (yp - ym)/2;
		selectWindow(epsy);
		setPixel(j,k,ey);

		yxm = getPixel(jm,k);
		yxp = getPixel(jp,k);

		eyx = (yxp - yxm)/2;
		selectWindow(epsyx);
		setPixel(j,k,eyx);
			
			
	}
	}
	
	selectWindow(epsx); save(dir+"epsx.tif"); close();
	selectWindow(epsy); save(dir+"epsy.tif"); close();
	selectWindow(epsxy);	save(dir+"epsxy.tif"); close();
	selectWindow(epsyx);	save(dir+"epsyx.tif"); close();
	
	//
	//		Will fix eps images in eps2eps12 when eps1 and eps2 are calculated and saved. However, 
	//			at this point eps images should have proper units of strain per hour since delX and delY are 
	//			properly scaled to micron per hour.
	//
	
	selectWindow(deltax); close();
	selectWindow(deltay); close();	

}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

// abs2vort

function abs2vort(dir)
{
//
//
//	converts the displacement maps into vorticity map.
//
//	Vorticity is calculated across a 3x3 matrix from the displacement image arrays.
//
//	the product of this function, vorticity, is stored locally with the original image pair.
//
// assumes: dx = dy = 1.0
//
//

	
	dx = 1.0;
	dy = 1.0;
	
	open(dir+"deltaX.tif");
	rename("deltaX");
	deltax = getTitle();
	// Apply the Sobel x-derivative kernel to u_y to get dudy_dx
	//run("Duplicate...", "title=dudy_dx"); //GM-Vorticity
	//run("Convolve...", "text1=[-1 0 1\n-2 0 2\n-1 0 1\n] normalize");
		
	open(dir+"deltaY.tif");
	rename("deltaY");
	deltay = getTitle();
	// Apply the Sobel y-derivative kernel to u_x to get dudx_dy
	//run("Duplicate...", "title=dudx_dy");
	//run("Convolve...", "text1=[-1 -2 -1\n0 0 0\n1 2 1\n] normalize");

	// Calculate vorticity (dudy_dx - dudx_dy)
		//imageCalculator("Subtract create", "dudy_dx", "dudx_dy");
		//rename("vorticity_D");
	
	selectWindow("deltaY");
	wid = getWidth();
	hei = getHeight();
	sli = nSlices;
	
	vort = "vorticity";	
	newImage(vort, "32-bit", wid, hei, 1);
	
	for (j=2; j<=(wid-1); j++)
	{
	for (k=2; k<=(hei-1); k++) 	
	{
		jp = j+1;
		jm = j-1;

		kp = k+1;
		km = k-1;
		selectWindow(deltax);

		xp = getPixel(j,kp);		
		xm = getPixel(j,km);

		dudy = (xp - xm)/(2*dy);

		selectWindow(deltay);

		ym = getPixel(jm,k);
		yp = getPixel(jp,k);

		dvdx = (yp - ym)/(2*dx);
		
		omega = dvdx - dudy;
		
		selectWindow(vort);
		setPixel(j,k,omega);
			
			
	}
	}
	
	selectWindow(deltax); close();
	selectWindow(deltay); close();
	
	selectWindow(vort);
	run("Select All");
	run("Enlarge...", "enlarge=-3");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");
	run("phase"); fixminmax(); save(dir+"vorticity.tif"); close();
	
	//selectWindow("vorticity_D");
	//run("Select All");
	//run("Enlarge...", "enlarge=-3");
	//run("Make Inverse");
	//run("Set...", "value=0");
	//run("Select None");
	//run("phase"); fixminmax(); save(dir+"vorticityD.tif"); close();
	//selectWindow("dudx_dy");  close();
	//selectWindow("dudy_dx");  close();
}

//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 



function eps2eps12(dir)
{

//
//
//	converts the strain maps in the x- and y- directions into principal strains with angle. Also, generates area strain rate map.
//	Principle strains are calculated pixel-by-pixel.
//
//	products of this function, eps1, eps2, theta, and area are stored locally with the image pair.
//
//	additionally, this function 'cleans' up the maps by zeroing the boundary pixels, sets the
//	display values symmetrically, and installs the 'phase' LUT in the image. These products are
//	saved with others as 'fixed_' versions. Important factor -- allowsat - sets the percentage of pixels
//	that are allowed to be saturated in the new min/max display.
//
//

	path = dir;
		
	open(dir+"epsx.tif");
	rename("epsx");
	epsx = getTitle();

	open(dir+"epsy.tif");
	rename("epsy");
	epsy = getTitle();

	open(dir+"epsxy.tif");
	rename("epsxy");
	epsxy = getTitle();

	open(dir+"epsyx.tif");
	rename("epsyx");
	epsyx = getTitle();		

//
//	Calculate principle strains - along direction theta where shear strain where shear is zero.
//
	
	newImage("eps1", "32-bit", wid, hei, 1);
	eps1 = getTitle();
	
	newImage("eps2", "32-bit", wid, hei, 1);
	eps2 = getTitle();
	
	newImage("theta", "32-bit", wid, hei, 1);
	theta = getTitle();
	
	newImage("area", "32-bit", wid, hei, 1);
	area = getTitle();
	
	for (j=2; j<=(wid-1); j++)
	{
	for (k=2; k<=(hei-1); k++) 	
	{

		selectWindow(epsx);
		ex = getPixel(j,k);
		
		selectWindow(epsy);
		ey = getPixel(j,k);
		
		selectWindow(epsxy);
		exy = getPixel(j,k);  // engineering shear strain

		selectWindow(epsyx);
		eyx = getPixel(j,k);  // engineering shear strain, 
		
		eavg = exy;
		
		plus =sqrt(0.25*(ex-ey)*(ex-ey) + 0.25*eavg*eavg);

		e1 = 0.5*(ex + ey) + plus;
		e2 = 0.5*(ex + ey) - plus;
		
		a  = e1 + e2 + e1*e2;
		
		t = 0.5*atand(2*eavg, ex-ey);
		
//		
//		is it correct to calculate the theta from the exy? or should I use eavg = (exy+eyx)/2?

//		
//

		selectWindow(eps1);
		setPixel(j,k,e1);
		
		selectWindow(eps2);
		setPixel(j,k,e2);
		
		selectWindow(theta);
		setPixel(j,k,t);
		
		selectWindow(area);
		setPixel(j,k,a);
		

	}
	}
	
//
//	Fix edge effects and normalize LUT scale for Engineering Strains
//	1. sets a band of 2 pixels at the margins to zero 
//	2. normalizes to allow 0.25% saturated pixels
//

	allowsat = 0.25;

	selectWindow(epsx);
	run("Select All");
	run("Enlarge...", "enlarge=-3");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");
	run("phase");
	
	run("Enhance Contrast", "saturated="+allowsat);
	getMinAndMax(tmin, tmax);
	
	selectWindow(epsy); 
	run("Select All");
	run("Enlarge...", "enlarge=-3");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");
	run("phase");
	
	run("Enhance Contrast", "saturated="+allowsat);
	getMinAndMax(smin, smax);
	if (smin < tmin) tmin = smin;
	if (smax > tmax) tmax = smax;

	selectWindow(epsxy); 
	run("Select All");
	run("Enlarge...", "enlarge=-3");
	run("Make Inverse");
	run("Set...", "value=0");

	run("Select None");
	run("phase");
	
	run("Enhance Contrast", "saturated="+allowsat);
	getMinAndMax(smin, smax);
	if (smin < tmin) tmin = smin;
	if (smax > tmax) tmax = smax;
	
	selectWindow(epsyx); 
	run("Select All");
	run("Enlarge...", "enlarge=-3");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");
	run("phase");

	run("Enhance Contrast", "saturated="+allowsat);

	selectWindow(epsx); run("phase"); fixminmax(); save(path+"epsx.tif"); close();	
	
	selectWindow(epsy); run("phase"); fixminmax(); save(path+"epsy.tif"); close();
	
	selectWindow(epsxy); run("phase"); fixminmax(); save(path+"epsxy.tif"); close();
	
	selectWindow(epsyx); run("phase"); fixminmax(); save(path+"epsyx.tif"); close();
	
	
//
//	Fix edge effects and normalize LUT scale for Principle Strains
//	1. sets a band of 2 pixels at the margins to zero
//	2. normalizes to allow 0.25% saturated pixels
//

	allowsat = 0.25;

	
	selectWindow(eps1); 
	run("Select All");
	run("Enlarge...", "enlarge=-3");
	run("Make Inverse");
	run("Set...", "value=0");

	run("Select None");
	run("phase");
	
	run("Enhance Contrast", "saturated="+allowsat);
	getMinAndMax(tmin, tmax);
	
	selectWindow(eps2); 
	run("Select All");
	run("Enlarge...", "enlarge=-3");
	run("Make Inverse");
	run("Set...", "value=0");

	run("Select None");
	run("phase");
	
	run("Enhance Contrast", "saturated="+allowsat);
	
	selectWindow(eps1); run("phase"); fixminmax(); save(path+"eps1.tif"); close();

	selectWindow(eps2); run("phase"); fixminmax(); save(path+"eps2.tif"); close();

	selectWindow(theta); 
	run("Select All");
	run("Enlarge...", "enlarge=-2");
	run("Make Inverse");
	run("Set...", "value=0");

	run("Select None");
	run("Spectrum");
	
	setMinAndMax(-90, 90);
	run("Set Scale...", "distance=0 known=0 unit=degrees");
	save(path+"theta.tif"); close();
	
	selectWindow(area); 
	run("Select All");
	run("Enlarge...", "enlarge=-3");
	run("Make Inverse");
	run("Set...", "value=0");

	run("Select None");
	run("Enhance Contrast", "saturated="+allowsat);
	
	run("phase"); fixminmax(); save(path+"area.tif"); close();

}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function eps2ellipse(dspan, dir, f1)
{
//
//
//	draws principal strain ellipses as the strain circles into a grid of the image.
//
//	NOTE: the size of the strain circles are scaled in each image! When combined in a timelapse their scales are not correct.
//
//

	
	path = dir;

	open(dir+"eps1.tif");
	rename("eps1");
	open(dir+"eps2.tif");
	rename("eps2");
	open(dir+"theta.tif");
	rename("theta");
	
	roiManager("reset");
	
//
//	dsquare is the size of the box for each strain ellipse
//	radius is the scale for the ellipse, relative to the box for the ellipse.
//	The ellipses are drawn scaled to the max radius.
//
	dsquare = dspan;
	radius = dsquare/5;
//	
//	
//
//

	eps1 = "eps1";
	eps2 = "eps2";
	theta = "theta";

	selectWindow(eps2);
	eps2 = getTitle();

	selectWindow(theta);
	theta = getTitle();
	
	selectWindow(eps1);
	eps1 = getTitle();
	run("Select All");
	getMinAndMax(smin, smax);
	roiManager("Add");
	
	getSelectionBounds(xbox, ybox, rwidth, rheight);
	
	run("Select None");
	
	newImage("Cosine Theta", "32-bit", rwidth, rheight, 1);
	costheta = getTitle();
	
	newImage("Sine Theta", "32-bit", rwidth, rheight, 1);
	sintheta = getTitle();
	
	makeSineCos(theta, costheta, sintheta);
	
	newImage("Ellipses", "16-bit black", rwidth, rheight, 1);
	ellipses = getTitle();
	
	run("Select All");
	
	if (rwidth == 0)
	{
		ShowMessage("Requires an ROI drawn within a cell");
		exit;
	}
	
	offsetx = (rwidth - dsquare*floor(rwidth/dsquare))/2+dsquare;
	offsety = (rheight - dsquare*floor(rheight/dsquare))/2+dsquare;
	
	SquareROIFill(dsquare, offsetx, offsety, rwidth, rheight);
	
	EliminateOutsiders();
	
	nrois = roiManager("Count");
	run("Set Measurements...", "mean redirect=None decimal=6");
	setLineWidth(2);
	
	setColor(255,255,255);
		
	for (i=1;i<nrois; i++)
	{
		selectWindow(costheta);
		roiManager("Select",i);
		Roi.getBounds(x, y, width, height);
		roiManager("Measure");
		meancos = getResult("Mean");
		
		selectWindow(sintheta);
		roiManager("Select",i);
		Roi.getBounds(x, y, width, height);
		roiManager("Measure");
		meansine = getResult("Mean");
		
		angle = atand (meansine, meancos);
		
		selectWindow(eps1);
		roiManager("Select",i);
		roiManager("Measure");
		major = getResult("Mean");
		
		selectWindow(eps2);
		roiManager("Select",i);
		roiManager("Measure");
		minor = getResult("Mean");
		
//
// 		Calculate the strain circle. The strain circle is based on a circle with fixed
//			radius and changes shape according to principle strains and orientation.
//			This macro draws a unit circle in the upper left corner. Increases
//			or decreases in the diameter reflected contraction or dilation in the 
//			principle strains (major axis = eps1, minor axis = eps2, 
//			orientation = theta).
//
		
		min = radius + radius*(minor/smax);
		maj = radius + radius*(major/smax);

		selectWindow(ellipses);
		drawEllipse(x+ dsquare/2, y + dsquare/2, maj, min, angle);

	}
//
//  Draw undeformed circle in upper left corner
//
	selectWindow(ellipses);
	drawEllipse(dsquare/3, dsquare/3, radius, radius, 90);
	run("Select None");
	
	open(dir+f1);
	run("16-bit");
	ff1 = getTitle();
	
//
//	Need ff1 to match the 16-bit depth of the ellipse image
//
	if (bitDepth() == 8) run("16-bit");
	
	run("Merge Channels...", "c6=["+ff1+"] c5=["+ellipses+"] create ignore keep");  // magenta tissue, cyan overlay
	save(dir+"start frame with ellipses "+dspan+".tif"); close();
	
	selectWindow(ellipses);
	save(path+"ellipses.tif"); close();
	
	selectWindow(costheta); close();
	selectWindow(sintheta); close();
	selectWindow(eps1); close();
	selectWindow(eps2); close();
	selectWindow(theta); close();
	
	selectWindow(ff1); close();
	

}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function abs2vector(dspan, arrowtype, dir, f1)
{
//
//
//	draws displacements as vectors into a grid of the image.
//
//	NOTE: the size of the vectors are scaled in each image! When combined in a timelapse the lengths are not correct.
//
//
	path = dir;

	
	open(dir+"deltaX.tif");
	rename("deltaX");
	deltax = getTitle();
	
	open(dir+"deltaY.tif");
	rename("deltaY");
	deltay = getTitle();

	roiManager("reset");

//
//	dsquare is the size of the box for each displacement vector
//	radius is the scale for the vector, relative to the box for the vector.
//	The ellipses are drawn scaled to the max radius.
//
//

	dsquare = dspan;
	vlen = dsquare/2;
	
//
//
//
//

	selectWindow(deltax);

	run("Select All");
	roiManager("Add");
	run("Enlarge...", "enlarge=-2");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");

	selectWindow(deltax);
	roiManager("Select",0);
	resetMinAndMax();
	getMinAndMax(tmin, tmax);
	run("Select None");

	selectWindow(deltay);

	run("Select All");
	run("Enlarge...", "enlarge=-2");
	run("Make Inverse");
	run("Set...", "value=0");
	run("Select None");

	selectWindow(deltay);
	roiManager("Select",0);
	resetMinAndMax();
	getMinAndMax(smin, smax);
	run("Select None");

	smax = abs(smax);
	if (abs(smin) > abs(smax)) smax = abs(smin);
	if (abs(tmin) > abs(tmax)) tmax = abs(tmin);
	if (abs(tmax) > abs(smax)) smax = abs(tmax);

	getSelectionBounds(xbox, ybox, rwidth, rheight);

	run("Select None");

	newImage("Vectors", "16-bit black", rwidth, rheight, 1);
	vectors = getTitle();
	run("Select All");

	if (rwidth == 0)
	{
		ShowMessage("Requires an ROI drawn within a cell");
		exit;
	}

	offsetx = (rwidth - dsquare*floor(rwidth/dsquare))/2+dsquare;
	offsety = (rheight - dsquare*floor(rheight/dsquare))/2+dsquare;

	SquareROIFill(dsquare, offsetx, offsety, rwidth, rheight);

	EliminateOutsiders();

	nrois = roiManager("Count");
	run("Set Measurements...", "mean redirect=None decimal=6");

	setColor(255,255,255);

	for (i=1;i<nrois; i++)
	{
		selectWindow(deltax);
		roiManager("Select",i);
		Roi.getBounds(x, y, width, height);
		roiManager("Measure");
		meanX = getResult("Mean");

		selectWindow(deltay);
		roiManager("Select",i);
		Roi.getBounds(x, y, width, height);
		roiManager("Measure");
		meanY = getResult("Mean");

//
// 		Calculate the vector length. vlen dictates the grid spacing
//

		vectX = 2*vlen*(meanX/smax);
		vectY = 2*vlen*(meanY/smax);

		x1 = x + vlen;
		y1 = y + vlen;
		x2 = x + vlen + vectX;
		y2 = y + vlen + vectY;

		selectWindow(vectors);
		makeArrow(x1, y1, x2, y2, arrowtype);
		run("Draw", "slice");

	}
//
//  Draw maximum +x vector in upper left corner
//
	selectWindow(vectors);
	x1 = dsquare/2;
	y1 = dsquare/2;
	x2 = dsquare/2 + dsquare/2;
	y2 = dsquare/2;

	makeArrow(x1, y1, x2, y2, arrowtype);
	run("Draw", "slice");
	run("Select None");

	save(path+"vectors.tif"); 
	vectors = getTitle();

	
	open(dir+f1);
	run("16-bit");
	ff1 = getTitle();
	
	run("Merge Channels...", "c6=["+ff1+"] c5=["+vectors+"] create ignore keep");  // magenta tissue, cyan overlay
	save(dir+"start frame with vectors "+dspan+" "+arrowtype+".tif"); close();
		
	selectWindow(ff1); close();
	selectWindow(vectors); close();
	
	selectWindow(deltax); close();
	selectWindow(deltay); close();
	
}

//
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
//  ********************      ********************      ********************      ********************
// 
//Calculating Absolute Curvature magnitude values
function AbsCurvRotation(dir){    
	path = dir;
	open(path+"deltaX.tif");
	rename("deltaX");
	id1 = getImageID();
    selectImage(id1);
    u_title = getTitle();
		
	open(path+"deltaY.tif");
	rename("deltaY");
    id2 = getImageID();
    v_title = getTitle();
    
	selectImage(id1);

	wid = getWidth();
	hei = getHeight();
	 // Create a new image to store curvature vorticity values
    newImage("Absolute Curvature Map", "32-bit black", wid, hei, 1);
    curvature_id = getImageID();
    
    // Calculate curvature vorticity for each pixel
    for (y = 2; y < hei - 1; y++) {
        for (x = 2; x < wid - 1; x++) {
            // Get u values
            selectImage(id1);
            u = getPixel(x, y);
            u_x_plus = getPixel(x+1, y);
            u_x_minus = getPixel(x-1, y);
            u_y_plus = getPixel(x, y+1);
            u_y_minus = getPixel(x, y-1);

            // Get v values
            selectImage(id2);
            v = getPixel(x, y);
            v_x_plus = getPixel(x+1, y);
            v_x_minus = getPixel(x-1, y);
			v_y_plus = getPixel(x, y+1);
            v_y_minus = getPixel(x, y-1);
            
            // Calculate derivatives
            du_dx = (u_x_plus - u_x_minus) / 2;
            du_dy = (u_y_plus - u_y_minus) / 2;
            dv_dx = (v_x_plus - v_x_minus) / 2;
            dv_dy = (v_y_plus - v_y_minus) / 2;

            // Calculate curvature
            numerator = abs(du_dx * dv_dy - du_dy * dv_dx);
            //denominator = pow(u*u + v*v, 1.5);
            denominator = u*u + v*v;
            
            // Avoid division by zero
            if (denominator < 1e-10) {
                curvature = 0;
            } else {
                curvature = numerator / denominator;
            }

            // Set curvature value
            selectImage(curvature_id);
            setPixel(x, y, curvature);
        }
        showProgress(y / (hei - 2));
    }
	
	// Display Curvature Map
    selectImage(curvature_id);
    resetMinAndMax();
    run("Fire");
    setMinAndMax(0, 0.001);
    setMetadata("Label", "Absolute Curvature");
    run("Select All");
    run("Enlarge...", "enlarge=-3");
    run("Make Inverse");
    run("Set...", "value=0");
    run("Select None");
    saveAs("tiff", path+"abscurv");
    close();
    selectImage(id1);
    close();
    selectImage(id2);
    close();
}
//
//  ********************      ********************      ********************      ********************
//  ********************         MORE FUNCTIONS         ********************      ********************
//  ********************      ********************      ********************      ********************
// 
function SetMask(s1, dir, masktype) { 
	
	if (File.exists(dir+"MASK.tif")== 0) {

		// Create Mask file for bUnwarpJ
			setBatchMode(true);
			roiManager("reset");
			selectWindow(s1);
			sample = getTitle();
			setTool("oval");
			getDimensions(Rwidth, Rheight, Rchannels, Rslices, Rrframes);
			
			selectWindow(sample);
			makeOval(44, 4, 1940, 1818);
			setBatchMode("exit and display");
			
			//Get initial Mask		
					Dialog.createNonBlocking("Create a Mask for bUnwarpJ");
					Dialog.addMessage("----------------------------------------------");
					Dialog.addMessage("Move the ROI to the location around the Embryo");
					Dialog.addMessage("----------------------------------------------");
					Dialog.setLocation(500,500);
					Dialog.show();
					
				roiManager("add");
				setBatchMode("hide");
				
			newImage("MASK", "16-bit black", Rwidth, Rheight, 1);
			mask = getTitle();
			roiManager("select", 0);
			setBackgroundColor(0, 0, 0);
			run("Clear Outside");
			setForegroundColor(255, 255, 255);
			run("Fill", "slice");
			setAutoThreshold("Default dark");
			setOption("BlackBackground", false);
			run("Convert to Mask");
				if (masktype == "Mask Inside"){
					run("Invert"); //For masking inner regions
				}
			saveAs("Tiff", dir+"MASK");
			close();
				}
}
//
//  ********************      ********************      ********************      ********************
//  ********************      UTILITIES UTILITIES       ********************      ********************
//  ********************      ********************      ********************      ********************
// 

function makeSineCos(angle, cosine, sine)
{
//
//	Need sine and cosine images of angle image to calculate mean angles.
// 	The image angle is filled with angles in degrees
//

	
	selectWindow(angle);
	run("Duplicate...", " ");
	rename("temp");
	run("Macro...", "code=v=sin(v*PI/180)");
	
	run("Select All");
	run("Copy");
	
	selectWindow(sine);
	run("Paste");
	
	selectWindow("temp");
	close();
	
	selectWindow(angle);
	run("Duplicate...", " ");
	rename("temp");
	run("Macro...", "code=v=cos(v*PI/180)");

	run("Select All");
	run("Copy");

	selectWindow(cosine);
	run("Paste");
		
	selectWindow("temp");
	close();

}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function fixzeromax()
{
//
//
//	Often when displaying both positive and negative valued 32-bit real images we want to center the LUT (e.g. "phase") around the zero value.
//	This function collects the min and max from the entire stack and sets the min/max values for display.
//
//
	getStatistics(voxelCount, mean, smin, smax, stdDev);
	setMinAndMax(0, smax);
	run("Select None");
	
}

function fixminmax()
{
//
//
//	Often when displaying both positive and negative valued 32-bit real images we want to center the LUT (e.g. "phase") around the zero value.
//	This function collects the min and max from the entire stack and sets the min/max values for display.
//
//
	getStatistics(voxelCount, mean, smin, smax, stdDev);
	if (abs(smax) > abs(smin))
	{
		smin = - smax;
	}
	else
	{
		smax = abs(smin);
	}
	setMinAndMax(smin, smax);
	run("Select None");
	
}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function fixzeromaxstack()
{
//
//
//	Often when displaying both positive and negative valued 32-bit real images we want to center the LUT (e.g. "phase") around the zero value.
//	This function collects the min and max from the entire stack and sets the min/max values for display.
//
//
	Stack.getStatistics(voxelCount, mean, smin, smax, stdDev);
	setMinAndMax(0, smax);
	run("Select None");
	
}

function fixminmaxstack()
{
//
//
//	Often when displaying both positive and negative valued 32-bit real images we want to center the LUT (e.g. "phase") around the zero value.
//	This function collects the min and max from the entire stack and sets the min/max values for display.
//
//
	Stack.getStatistics(voxelCount, mean, smin, smax, stdDev);
	if (abs(smax) > abs(smin))
	{
		smin = - smax;
	}
	else
	{
		smax = abs(smin);
	}
	setMinAndMax(smin, smax);
	run("Select None");
}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function pad3(n) 
{

//
//	takes a number, converts to text, and padds with leading zeros until reaches 3 places. 
//	Eg. 3 --> "003", 99 --> "099", 234 --> "234"
//
      str = toString(n);
      while (lengthOf(str)<3)
          str = "0" + str;
      return str;
}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function StackByRecurse(dir, target, source) 
{
//
//	Builds a stack called target from individual files whose name matches source by 
//		recursing into the folder tree headed by dir
//
	
	list = getFileList(dir);
	for (i=0; i<list.length; i++) 
	{
		if (endsWith(list[i], "/"))
		{
			StackByRecurse(""+dir+list[i], target, source);
		}
		else
		{
			if (list[i] == source)
			{
				open(dir+list[i]);
				run("16-bit");

				if (!isOpen(target))
				{
					selectWindow(source);
					if (!is("composite"))
					{
						iscomp = false;
						wid = getWidth();
						hei = getHeight();
						itype = bitDepth();
						if (itype == 8) ctype = "8-bit";
						if (itype == 16) ctype = "16-bit";
						if (itype == 24) ctype = "RGB";
						if (itype == 32) ctype = "32-bit";
						newImage(target, ctype, wid, hei, 1);
						selectWindow(source);
					}
					else
					{
						iscomp = true;
						ctype = "RGB";
						wid = getWidth();
						hei = getHeight();
						newImage(target, ctype, wid, hei, 1);
						selectWindow(source);
					
					}
				}
				selectWindow(source);
				if (is("composite"))
				{
					run("Stack to RGB");
					newsource = getTitle();
					selectWindow(source); close();
					selectWindow(newsource);
				}
				else
				{
					// do nothing
				}
				
				run("Select All");
				run("Copy");
				close();
				selectWindow(target);
				run("Add Slice");
				run("Paste");
			}
		}
	}
}


function TrajectoryStackByRecurse(dir, sample, target, source) 
{			
//
//	"dir" is the root directory of the stack
//	"sample" is an image from the stack used for "size"
//	"target" is the stack where the dot trajectories will be placed
//	"source" is the direct transfer file that is being looked for. This file is used by bUnwarpJ to deform
//		the random dot image to form new displaced image, "dotlast", that is added to the end of the mock-trajectory stack. 
//		This mock trajectory is intended to look like a time-lapse of H2B-GFP expressing cells.
//

	selectWindow(sample);
	
	wid = getWidth();
	hei = getHeight();
	
	if (dotfile != true)
	{
		newImage("polkadots", "16-bit black", wid, hei, 1);
		dotstart = getTitle();

		dotfile = true;

		setForegroundColor(255, 255, 255);
		setBackgroundColor(0, 0, 0);

		diam = 5;

		for (i=1; i<3000; i++) 
		{
			colrand = (pow(2,16)-1)*random();
			setColor(colrand);
			xrand = wid*random();
			yrand = hei*random();
			diamdot = diam+ (diam/2)*(random()-0.5);
			makeOval(xrand + diamdot/2, yrand + diamdot/2, diamdot, diamdot);
			run("Fill", "slice");
			run("Select None");
		}
		run("Duplicate...", "title=dotlast");
		dotlast = getTitle();
		
		newImage(target, "16-bit black", wid, hei, 1);
		
		selectWindow(dotstart);
		run("Select All");
		run("Copy");
		selectWindow(target);
		run("Paste");
		run("Select None");
		selectWindow(dotstart); close();
		
	}
	else
	{

//		do nothing

	}
//
//	Builds a Trajectory Stack called target by elastically deforming a "polka dot" image by 
//		recursing into the folder tree headed by dir
//
	
	list = getFileList(dir);
	for (i=0; i<list.length; i++) 
	{
		if (endsWith(list[i], "/"))
		{
			TrajectoryStackByRecurse(""+dir+list[i], sample, target, source);
		}
		else
		{
			if (list[i] == source)
			{			
				elast = dir+list[i];
				
				selectWindow(dotlast);
				
				call("bunwarpj.bUnwarpJ_.loadElasticTransform", elast, sample, dotlast);
				
				selectWindow(dotlast);
				run("Select All");
				run("Copy");
				selectWindow(target);
				run("Add Slice");
				run("Paste");
				selectWindow(dotlast);
				run("Select None");
			}
		}
	}
//	selectWindow(dotlast); close();

}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function drawEllipse(x, y, a, b, angle) {
      autoUpdate(false);
      setLineWidth(1);
      beta = -angle * (PI/180);
      for (i=0; i<=360; i+=2) {
          alpha = i*(PI/180) ;
          X = x + a*cos(alpha)*cos(beta) - b*sin(alpha)*sin(beta);
          Y = y + a*cos(alpha)*sin(beta) + b*sin(alpha)*cos(beta);
          if (i==0) moveTo(X, Y); else lineTo(X,Y);
          if (i==0) {ax1=X; ay1=Y;}
          if (i==90) {bx1=X; by1=Y;}
          if (i==180) {ax2=X; ay2=Y;}
          if (i==270) {bx2=X; by2=Y;}
      }
      drawLine(ax1, ay1, ax2, ay2);
      drawLine(bx1, by1, bx2, by2);
      updateDisplay;
}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function drawArrow(x1, y1, x2, y2, arrowWidth, arrowLength) 
{
      setupUndo();
      setLineWidth(arrowWidth);
 //     size = 8+10*arrowWidth*0.5;
      size = 16+20*arrowWidth*0.5;
      dx = x2-x1;
      dy = y2-y1;
      ra = sqrt(dx*dx + dy*dy);
      dx /= ra;
      dy /= ra;
      x3 = x2-dx*size;
      y3 = y2-dy*size;
      r = 0.35*size;
      x4 = round(x3+dy*r);
      y4 = round(y3-dx*r);
      x5 = round(x3-dy*r);
      y5 = round(y3+dx*r);
      drawLine(x1, y1, x2-dx*size, y2-dy*size);
//      if (arrowLength==-1 || arrowLength>size)
 //        drawLine(x1, y1, x2-dx*size, y2-dy*size);
      makePolygon(x4,y4,x2,y2,x5,y5);
      fill;
}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function atand (y, x)
{
	angle=(180/PI)*atan2(y,x);
	return angle;
}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function MakeSquareROI(x,y,d)
{

//
//	x and y are the centroids of the squareROI
//	d is the width
//
	var delx, dely1, dely2, x1,x2,x3,x4,y1,y2,y3,y4;
	
	delx = d/2;
	dely = d/2;
	
	x1 = x - delx;
	y1 = y - dely;

	x2 = x + delx;
	y2 = y - dely;

	x3 = x + delx;
	y3 = y + dely;

	x4 = x - delx;
	y4 = y + dely;
	makePolygon(x1,y1,x2,y2,x3,y3,x4,y4);
}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//

function SquareROIFill(dsquare, offsetx, offsety, frwidth, frheight)
{
	
//	find out how many squares pack in height
	
	nwidth = floor( frwidth / dsquare);
	nheight = floor( frheight / dsquare);
	
// offset of first hexagon in upper left

	
	icell = 1;
	
	for (j=1;j<nheight; j++)
	{	
		for (i=1;i<nwidth; i++)
		{
			MakeSquareROI(offsetx + (i-1)*(dsquare), offsety + (j-1)*(dsquare),dsquare);
			roiManager("Add");				
			icell++;
		}	
	}
	ncells = icell-1;
}

//
//  ********************      UTILITIES UTILITIES       ********************      ********************
//


function EliminateOutsiders()
{
//
// This function expects a list of ROIs with the first (i=0) being the container.
//
// It will eliminate all subsequent ROIs that do not lie within the container.
//
// Each time an ROI is eliminated the list is updated...
//
	stackID = getImageID();
	
	nrois = roiManager("Count");
	roiManager("Select", 0);
	getStatistics(area1);

	i = 1;
	nrois = roiManager("Count");
	while (i < nrois)
	{
		setKeyDown("none");
		selectImage(stackID);
		roiManager("Select", 0);
		setKeyDown("shift");
		roiManager("Select", i);
		setKeyDown("none");
		getStatistics(areaboth);
		//
		//	check for overlapping selections
		//
		if (areaboth == area1) // ROI i is completely contained within ROI-zero
		{
			// do nothing
			i++;
		}
		else	// the areas are completely different or they partially overlap
		{
			roiManager("Select",i);
			roiManager("Delete");
		}
		nrois = roiManager("Count");
	}
}
